/**
 * IntroductionDeversiFiLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const chai = require('chai');
const assert = chai.assert;
const TestHelper = require("../TestHelper");
const APIHelper = require("../../lib/APIHelper");
const testerlib = require("../../lib");
const testConfiguration = require("../TestBootstrap");

const controller = testerlib.WriteEndpointsController;
const ReleaseTokens = testerlib.ReleaseTokens;

describe("WriteEndpointsController Tests", function tests() {
    this.timeout(testConfiguration.TEST_TIMEOUT);

    /**
     * The submit order endpoint requires an order prepared in a certain message format. This message format matches that defined by [0xproject](https://github.com/0xProject/0x-protocol-specification/blob/master/v2/v2-specification.md#order-message-format).

### Order Message Format

Below is an example 0x v2 order. This trading standard relies on the use of smart contracts to allow exchanges to use funds securely and strictly for filling orders from traders. 

Combined with the wrappers mentioned in the Token Wrapper Lock section, this allows Ethfinex to integrate the decentralized orders directly into the main orderbook while still ensuring the same promises of decentralized exchanges.

The wrapper token contracts main use is to guarantee that orders submitted to Ethfinex will be fillable, which allows seamless integration and trading against centralized users. The contracts however only allow Ethfinex to use the locked funds for the purpose of filling orders, which guarantees their safety for the trader.

**Warning:** Trustless orders will always be settled at the exact price you specify, and can never be adjusted by Ethfinex, even if it is at a worse price than the market.

**For example, when placing a sell order, if the price entered is below the highest bid available on the order book, the order will be executed instantly at market. However, the amount you receive will reflect only the price that you entered, and not the market price at the time of execution.**

Note: for orders on USDT markets there is an additional conversion which must be made between USD and USDT markets. [See here for more](#usd-tether-markets).

---
```javascript
let order = {
makerAddress: userAddress, // Your ethereum address
takerAddress: '0x0000000000000000000000000000000000000000',

feeRecipientAddress: ethfinexAddress, // ethfinex provided address

senderAddress: ethfinexAddress,

makerAssetAmount: web3.utils.toBN(sellAmount), // in the smallest unit of the token, e.g in wei for ether

takerAssetAmount: web3.utils.toBN(buyAmount), // as above

makerFee: web3.utils.toBN('0'), // constant

takerFee: web3.utils.toBN('0'), // constant

expirationTimeSeconds: web3.utils.toBN(Math.round((new Date()).getTime() / 1000) + ((defaultExpiry || 60) * 60)), // part after the plus can be replaced, first part is constant
    
salt: ZeroEx.generatePseudoRandomSalt(), // as is

makerAssetData: assetDataUtils.encodeERC20AssetData(sellCurrency.wrapperAddress.toLowerCase()), // token type and wrapper token address
  
takerAssetData: assetDataUtils.encodeERC20AssetData(buyCurrency.wrapperAddress.toLowerCase()),  // token type and wrapper token address
  }
```

The `taker` and `feeRecipient` should be Ethfinex's address, the `takerFee` and `makerFee` should be 0 (Ethfinex takes the fee out of the traded amount), the token addresses involved are the wrappers, and the `exchangeContractAddress` is the deployed Exchange contract to which matched orders will be submitted to execute. This order then must be signed as demonstrated above and have this added to the object.

### Making orders from smart contracts

Orders can be placed on behalf of a contract by its owner or manager, and must be signed by them.
An additional field in the `meta` order object must be specified to enable this.

`meta.sigType = 'contract'`

When set this will ensure orders are validated to see if the signer has permission to sign trades on behalf of the smart contract.

`gid`, string, Group Order ID

`cid`, string, Client order ID

`symbol`, string, Trading Symbol Pair

`amount`, string, Positive for buying, negative for selling

`price`, string, Price

`meta`, object, The signed 0x order object used by the decentralized trading protocol

`protocol`, string, The protocol used for decentralized trading (0x format currently supported)
     */
    it("should testSubmitOrder response", function testSubmitOrderTest(done) {
        // parameters for the API call
        let accept = 'application/json';
        let contentType = 'text/html';
        let body = '{ \n\'gid\': 1, \n\'cid\': 1575844655218, \n\'type\': EXCHANGE LIMIT, \n\'symbol\':tETHUSD, \n\'amount\': -1, \n\'price\': 201, \n\'meta\': signedOrder, \n\'protocol\': 0x\n}\n';

        controller.createSubmitOrder(accept, contentType, body, function callback(error, response, context) {
            // test response code
            assert.equal(200, context.response.statusCode);
            assert.isNotNull(response);
            assert.equal('[1185819952]', context.response.body);
            done();
        }).catch(() => undefined);
    });

    /**
     * To cancel an order, the order ID must be signed as follows, and included in the signature field:
```javascript
const sig = await efx.sign(parseInt(orderId).toString(16))
const sigConcat = ethUtils.toRpcSig(sig.v, ethUtils.toBuffer(sig.r), ethUtils.toBuffer(sig.s))
```
N.B. the signature is a hex string here, and if using ecsign function from a library which returns v, r, s it must be concatenated.


     */
    it("should testCancelOrder response", function testCancelOrderTest(done) {
        // parameters for the API call
        let accept = 'application/json';
        let contentType = 'application/json';

        controller.createCancelOrder(accept, contentType, function callback(error, response, context) {
            // test response code
            assert.equal(200, context.response.statusCode);
            assert.isNotNull(response);
            assert.equal('[1185819944]', context.response.body);
            done();
        }).catch(() => undefined);
    });

    /**
     * Requests an early unlock signature for the specified addresses, allowing tokens to be withdrawn before the locktime is over. The response should include A) `releaseSignature` B) `unlockUntilBlockNumber`
These are then submitted to the token wrapper lock contract (with releaseSignature broken down into v, r, s): `withdraw(amountToWithdraw, v, r, s,  unlockUntil )`
NB: As long as there is a pending unlock for an address, no orders will be accepted from that address and no orders will be filled.


     */
    it("should testReleaseTokens response", function testReleaseTokensTest(done) {
        // parameters for the API call
        let accept = 'application/json';
        let contentType = 'application/json';

        controller.createReleaseTokens(accept, contentType, function callback(error, response, context) {
            // test response code
            assert.equal(200, context.response.statusCode);
            assert.isNotNull(response);
            assert.isTrue(TestHelper.isProperSubsetOf(context.response.body, {"releaseSignature": {"v": "0x1b", "r": "0x7b860bea4eeca571d898fa2d74b783160a3bfaba797b6043decaaccf29c1bd8a", "s": "0x05e0b81f39be41e3e570ffa3b68b76ff4ae2d5125aa6c5b937fb80a549f570d9"}, "unlockUntil": 15323360}, false, true, false));
            done();
        }).catch(() => undefined);
    });
});
