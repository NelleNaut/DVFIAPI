/**
 * IntroductionDeversiFiLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class WriteEndpointsController {
    /**
     * The submit order endpoint requires an order prepared in a certain message format. This
     * message format matches that defined by [0xproject](https://github.com/0xProject/0x-
     * protocol-specification/blob/master/v2/v2-specification.md#order-message-format).
     * ### Order Message Format
     * Below is an example 0x v2 order. This trading standard relies on the use of smart
     * contracts to allow exchanges to use funds securely and strictly for filling orders from
     * traders.
     * Combined with the wrappers mentioned in the Token Wrapper Lock section, this allows
     * Ethfinex to integrate the decentralized orders directly into the main orderbook while
     * still ensuring the same promises of decentralized exchanges.
     * The wrapper token contracts main use is to guarantee that orders submitted to Ethfinex
     * will be fillable, which allows seamless integration and trading against centralized users.
     * The contracts however only allow Ethfinex to use the locked funds for the purpose of
     * filling orders, which guarantees their safety for the trader.
     * **Warning:** Trustless orders will always be settled at the exact price you specify, and
     * can never be adjusted by Ethfinex, even if it is at a worse price than the market.
     * **For example, when placing a sell order, if the price entered is below the highest bid
     * available on the order book, the order will be executed instantly at market. However, the
     * amount you receive will reflect only the price that you entered, and not the market price
     * at the time of execution.**
     * Note: for orders on USDT markets there is an additional conversion which must be made
     * between USD and USDT markets. [See here for more](#usd-tether-markets).
     * ---
     * ```javascript
     * let order = {
     * makerAddress: userAddress, // Your ethereum address
     * takerAddress: '0x0000000000000000000000000000000000000000',
     * feeRecipientAddress: ethfinexAddress, // ethfinex provided address
     * senderAddress: ethfinexAddress,
     * makerAssetAmount: web3.utils.toBN(sellAmount), // in the smallest unit of the token, e.g
     * in wei for ether
     * takerAssetAmount: web3.utils.toBN(buyAmount), // as above
     * makerFee: web3.utils.toBN('0'), // constant
     * takerFee: web3.utils.toBN('0'), // constant
     * expirationTimeSeconds: web3.utils.toBN(Math.round((new Date()).getTime() / 1000) +
     * ((defaultExpiry || 60) * 60)), // part after the plus can be replaced, first part is
     * constant
     * 
     * salt: ZeroEx.generatePseudoRandomSalt(), // as is
     * makerAssetData: assetDataUtils.encodeERC20AssetData(sellCurrency.wrapperAddress.
     * toLowerCase()), // token type and wrapper token address
     * 
     * takerAssetData: assetDataUtils.encodeERC20AssetData(buyCurrency.wrapperAddress.
     * toLowerCase()),  // token type and wrapper token address
     * }
     * ```
     * The `taker` and `feeRecipient` should be Ethfinex's address, the `takerFee` and `makerFee`
     * should be 0 (Ethfinex takes the fee out of the traded amount), the token addresses
     * involved are the wrappers, and the `exchangeContractAddress` is the deployed Exchange
     * contract to which matched orders will be submitted to execute. This order then must be
     * signed as demonstrated above and have this added to the object.
     * ### Making orders from smart contracts
     * Orders can be placed on behalf of a contract by its owner or manager, and must be signed
     * by them.
     * An additional field in the `meta` order object must be specified to enable this.
     * `meta.sigType = 'contract'`
     * When set this will ensure orders are validated to see if the signer has permission to sign
     * trades on behalf of the smart contract.
     * `gid`, string, Group Order ID
     * `cid`, string, Client order ID
     * `symbol`, string, Trading Symbol Pair
     * `amount`, string, Positive for buying, negative for selling
     * `price`, string, Price
     * `meta`, object, The signed 0x order object used by the decentralized trading protocol
     * `protocol`, string, The protocol used for decentralized trading (0x format currently
     * supported)
     *
     * @param {string} accept TODO: type description here
     * @param {string} contentType TODO: type description here
     * @param {string} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createSubmitOrder(accept, contentType, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/v1/trading/w/on';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'text/plain; charset=utf-8',
            Accept: accept,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: body,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const parsed = JSON.parse(_response.body);
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * To cancel an order, the order ID must be signed as follows, and included in the signature
     * field:
     * ```javascript
     * const sig = await efx.sign(parseInt(orderId).toString(16))
     * const sigConcat = ethUtils.toRpcSig(sig.v, ethUtils.toBuffer(sig.r), ethUtils.toBuffer(sig.
     * s))
     * ```
     * N.B. the signature is a hex string here, and if using ecsign function from a library which
     * returns v, r, s it must be concatenated.
     *
     * @param {string} accept TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCancelOrder(accept, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/v1/trading/w/oc';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Accept: accept,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    const parsed = JSON.parse(_response.body);
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Requests an early unlock signature for the specified addresses, allowing tokens to be
     * withdrawn before the locktime is over. The response should include A) `releaseSignature`
     * B) `unlockUntilBlockNumber`
     * These are then submitted to the token wrapper lock contract (with releaseSignature broken
     * down into v, r, s): `withdraw(amountToWithdraw, v, r, s,  unlockUntil )`
     * NB: As long as there is a pending unlock for an address, no orders will be accepted from
     * that address and no orders will be filled.
     *
     * @param {string} accept TODO: type description here
     * @param {string} contentType TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createReleaseTokens(accept, contentType, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.getBaseUri();

        const _pathUrl = '/v1/trading/w/releaseTokens';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            Accept: accept,
            'Content-Type': contentType,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'ReleaseTokens');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = WriteEndpointsController;
